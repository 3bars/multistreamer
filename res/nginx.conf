worker_processes <%= worker_processes %>;
error_log stderr <%= log_level %>;
daemon off;
pid logs/nginx.pid;

env LAPIS_ENVIRONMENT;
env LUA_PATH;
env LUA_CPATH;

events {
  worker_connections 1024;
}

http {
  lua_socket_log_errors off;

  resolver <%= dns_resolver %>;
  lua_ssl_trusted_certificate <%= ssl_trusted_certificate %>;
  lua_ssl_verify_depth <%= ssl_verify_depth %>;
  lua_shared_dict streams <%= lua_shared_dict_streams_size %>;
  lua_shared_dict writers <%= lua_shared_dict_writers_size %>;

  types {
    text/html                             html htm shtml;
    text/css                              css;
    text/plain                            txt;

    application/x-javascript              js;

    image/gif                             gif;
    image/jpeg                            jpeg jpg;
    image/png                             png;
    image/x-icon                          ico;
    image/svg+xml                         svg svgz;

    video/mp4                             mp4;
  }

  init_worker_by_lua_block {
    networks = require('multistreamer.networks')
    uuid = require'resty.jit-uuid'
    chatmgr = require('multistreamer.chat_manager').new()
    uuid.seed()
    ngx.timer.at(0,function()
      chatmgr:run()
    end)
  }

  server {
    listen <%= http_listen %>;
    lua_code_cache on;

    location <%= http_prefix %>/ {
      default_type text/html;
      content_by_lua_block {
        require('lapis').serve('app')
      }
    }

    location <%= http_prefix %>/static/ {
      alias <%= streamer_dir %>/static/;
    }

    location /favicon.ico {
      alias <%= streamer_dir %>/static/favicon.ico;
      log_not_found off;
      access_log off;
    }
    location /robots.txt {
      allow all;
      log_not_found off;
      access_log off;
    }
  }
}

rtmp_auto_push on;

rtmp {
  server {
    listen <%= rtmp_listen %>;
    chunk_size 4096;
    application <%= rtmp_prefix %> {
      live on;
      record off;
      meta copy;

      on_publish <%= private_http_url .. http_prefix .. '/on-publish' %>;
      on_publish_done <%= private_http_url .. http_prefix .. '/on-done' %>;
      on_update <%= private_http_url .. http_prefix .. '/on-update' %>;

      exec_push <%= lua_bin %> <%= script_path %> push $name;
      exec_kill_signal term;

    }
  }
}

stream {
  lua_socket_log_errors off;
  lua_code_cache on;
  lua_ssl_trusted_certificate <%= ssl_trusted_certificate %>;
  lua_ssl_verify_depth <%= ssl_verify_depth %>;
  lua_resolver <%= dns_resolver %>;

  init_worker_by_lua_block {
    start_time = ngx.now()
    uuid = require'resty.jit-uuid'
    uuid.seed()
    networks = require('multistreamer.networks')
    IRC = require('multistreamer.irc.server').new()
    ngx.timer.at(0,function()
      IRC:run()
    end)
  }
  server {
    listen <%= irc_listen %>;
    content_by_lua_block {
      local IRC = IRC
      local IRCServer = require'multistreamer.irc.server'
      local sock, err = ngx.req.socket(true)
      if err then ngx.exit(ngx.OK) end
      if not IRC:isReady() then ngx.exit(ngx.OK) end

      local ok, user = IRCServer.startClient(sock,IRC)
      if ok then
        local server = IRCServer.new(sock,user,IRC)
        server:run()
      end
    }
  }
}
